/*
 * This file was automatically generated by EvoSuite
 * Sat Apr 16 21:16:44 GMT 2022
 */

package org.apache.commons.lang3.WillEvoSuite;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.util.Collection;
import java.util.Comparator;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.Function;
import java.util.function.Supplier;
import java.util.stream.Collector;
import java.util.stream.DoubleStream;
import java.util.stream.LongStream;
import java.util.stream.Stream;
import org.apache.commons.lang3.stream.Streams;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true, useJEE = true) 
public class Streams_ESTest extends Streams_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test00()  throws Throwable  {
      LinkedList<Stream<String>> linkedList0 = new LinkedList<Stream<String>>();
      Streams.FailableStream<Stream<String>> streams_FailableStream0 = Streams.failableStream((Collection<Stream<String>>) linkedList0);
      Supplier<String> supplier0 = (Supplier<String>) mock(Supplier.class, new ViolatedAssumptionAnswer());
      doReturn((Object) null).when(supplier0).get();
      BiConsumer<String, Object> biConsumer0 = (BiConsumer<String, Object>) mock(BiConsumer.class, new ViolatedAssumptionAnswer());
      BiConsumer<String, String> biConsumer1 = (BiConsumer<String, String>) mock(BiConsumer.class, new ViolatedAssumptionAnswer());
      String string0 = streams_FailableStream0.collect(supplier0, (BiConsumer<String, ? super Stream<String>>) biConsumer0, biConsumer1);
      assertNull(string0);
  }

  @Test(timeout = 4000)
  public void test01()  throws Throwable  {
      LinkedList<DoubleStream> linkedList0 = new LinkedList<DoubleStream>();
      Streams.FailableStream<DoubleStream> streams_FailableStream0 = Streams.stream((Collection<DoubleStream>) linkedList0);
      Stream<DoubleStream> stream0 = streams_FailableStream0.stream();
      assertNotNull(stream0);
  }

  @Test(timeout = 4000)
  public void test02()  throws Throwable  {
      LinkedList<String> linkedList0 = new LinkedList<String>();
      Streams.FailableStream<String> streams_FailableStream0 = Streams.failableStream((Collection<String>) linkedList0);
      //streams_FailableStream0.assertNotTerminated();
  }

  @Test(timeout = 4000)
  public void test03()  throws Throwable  {
      Class<DoubleStream> class0 = DoubleStream.class;
      Streams.ArrayCollector<DoubleStream> streams_ArrayCollector0 = new Streams.ArrayCollector<DoubleStream>(class0);
      Function<List<DoubleStream>, DoubleStream[]> function0 = streams_ArrayCollector0.finisher();
      assertNotNull(function0);
  }

  @Test(timeout = 4000)
  public void test04()  throws Throwable  {
      Class<Object> class0 = Object.class;
      Streams.ArrayCollector<Object> streams_ArrayCollector0 = new Streams.ArrayCollector<Object>(class0);
      BinaryOperator<List<Object>> binaryOperator0 = streams_ArrayCollector0.combiner();
      assertNotNull(binaryOperator0);
  }

  @Test(timeout = 4000)
  public void test05()  throws Throwable  {
      Stream<String> stream0 = Streams.toStream((Collection<String>) null);
      assertNotNull(stream0);
  }

  @Test(timeout = 4000)
  public void test06()  throws Throwable  {
      LinkedList<String> linkedList0 = new LinkedList<String>();
      Stream<String> stream0 = linkedList0.stream();
      Stream<Object> stream1 = Stream.of((Object) stream0);
      Streams.FailableStream<Object> streams_FailableStream0 = new Streams.FailableStream<Object>(stream1);
  }

  @Test(timeout = 4000)
  public void test07()  throws Throwable  {
      Stream<DoubleStream> stream0 = Streams.of((DoubleStream[]) null);
      assertNotNull(stream0);
  }

//  @Test(timeout = 4000)
//  public void test08()  throws Throwable  {
//      Stream<String> stream0 = Stream.of("GD_+i;x8v\"E0");
//      Streams.FailableStream<String> streams_FailableStream0 = Streams.failableStream(stream0);
//      //streams_FailableStream0.makeTerminated();
//      // Undeclared exception!
//      try {
//        //streams_FailableStream0.makeTerminated();
//        fail("Expecting exception: IllegalStateException");
//
//      } catch(IllegalStateException e) {
//         //
//         // This stream is already terminated.
//         //
//         verifyException("org.apache.commons.lang3.stream.Streams$FailableStream", e);
//      }
//  }

  @Test(timeout = 4000)
  public void test09()  throws Throwable  {
      Class<Integer> class0 = Integer.class;
      Streams.ArrayCollector<Integer> streams_ArrayCollector0 = new Streams.ArrayCollector<Integer>(class0);
      Supplier<List<Integer>> supplier0 = streams_ArrayCollector0.supplier();
      assertNotNull(supplier0);
  }

  @Test(timeout = 4000)
  public void test10()  throws Throwable  {
      Class<DoubleStream> class0 = DoubleStream.class;
      Streams.ArrayCollector<DoubleStream> streams_ArrayCollector0 = new Streams.ArrayCollector<DoubleStream>(class0);
      Set<Collector.Characteristics> set0 = (Set<Collector.Characteristics>)streams_ArrayCollector0.characteristics();
      assertEquals(0, set0.size());
  }

  @Test(timeout = 4000)
  public void test11()  throws Throwable  {
      Class<String> class0 = String.class;
      Streams.ArrayCollector<String> streams_ArrayCollector0 = new Streams.ArrayCollector<String>(class0);
      BiConsumer<List<String>, String> biConsumer0 = streams_ArrayCollector0.accumulator();
      assertNotNull(biConsumer0);
  }

  @Test(timeout = 4000)
  public void test12()  throws Throwable  {
      Streams streams0 = new Streams();
  }

  @Test(timeout = 4000)
  public void test13()  throws Throwable  {
      Class<Object> class0 = Object.class;
      LinkedList<Object> linkedList0 = new LinkedList<Object>();
      Stream<Stream<DoubleStream>> stream0 = Streams.instancesOf((Class<? super Stream<DoubleStream>>) class0, (Collection<? super Stream<DoubleStream>>) linkedList0);
      assertNotNull(stream0);
  }

  @Test(timeout = 4000)
  public void test14()  throws Throwable  {
      Class<LongStream> class0 = LongStream.class;
      Collector<LongStream, ?, LongStream[]> collector0 = Streams.toArray(class0);
      assertNotNull(collector0);
  }

  @Test(timeout = 4000)
  public void test15()  throws Throwable  {
      LinkedList<String> linkedList0 = new LinkedList<String>();
      Stream<String> stream0 = Streams.nullSafeStream((Collection<String>) linkedList0);
      assertNotNull(stream0);
  }

  @Test(timeout = 4000)
  public void test16()  throws Throwable  {
      LinkedList<String> linkedList0 = new LinkedList<String>();
      Stream<String> stream0 = Streams.toStream((Collection<String>) linkedList0);
      Stream<Stream<String>> stream1 = Stream.of(stream0);
      Streams.FailableStream<Stream<String>> streams_FailableStream0 = Streams.stream(stream1);
      assertNotNull(streams_FailableStream0);
  }

  @Test(timeout = 4000)
  public void test17()  throws Throwable  {
      LinkedList<String> linkedList0 = new LinkedList<String>();
      Streams.FailableStream<String> streams_FailableStream0 = Streams.failableStream((Collection<String>) linkedList0);
      // Undeclared exception!
      try { 
        streams_FailableStream0.collect((Collector<? super String, Integer, Integer>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("java.util.Objects", e);
      }
  }

  @Test(timeout = 4000)
  public void test18()  throws Throwable  {
      DoubleStream[] doubleStreamArray0 = new DoubleStream[0];
      Stream<DoubleStream> stream0 = Streams.of(doubleStreamArray0);
      LinkedList<Object> linkedList0 = new LinkedList<Object>();
      Streams.FailableStream<Object> streams_FailableStream0 = Streams.stream((Collection<Object>) linkedList0);
      Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      BinaryOperator<Object> binaryOperator0 = BinaryOperator.maxBy((Comparator<? super Object>) comparator0);
      Object object0 = streams_FailableStream0.reduce(stream0, binaryOperator0);
      assertFalse(linkedList0.contains(object0));
  }
}
